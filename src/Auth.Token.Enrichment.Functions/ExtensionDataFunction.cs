using Auth.Token.Enrichment.Functions.Extensions;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using System.Diagnostics;
using System.Text.Json;

namespace Auth.Token.Enrichment.Functions;

public class ExtensionDataFunction(ILogger<ExtensionDataFunction> logger)
{
    /* private readonly ILogger<ExtensionDataFunction> _logger = logger; */

    private static readonly Action<ILogger, Exception?> _logExtensionDataFunctionTrigger =
        LoggerMessage.Define(
            LogLevel.Information,
            new EventId(0, nameof(ExtensionDataFunction)),
            "ExtensionDataFunction triggered");

    private static readonly Action<ILogger, Exception?> _logEmptyRequest =
        LoggerMessage.Define(
            LogLevel.Information,
            new EventId(0, nameof(ExtensionDataFunction)),
            "Empty request or reguest with no body was received and ignored");

    //private static readonly Action<ILogger> _logEmptyRequest2 =
    //    LoggerMessage.Define(
    //        LogLevel.Information,
    //        new EventId(0, nameof(ExtensionDataFunction)),
    //        "Empty request or reguest with no body was received and ignored");

    private static readonly Action<ILogger, string, Exception?> _logFunctionFailedError =
        LoggerMessage.Define<string>(
            LogLevel.Error,
            new EventId(1, nameof(ExtensionDataFunction)),
            "Error processing request: {Message}");

    [Function("ExtensionDataFunction")]
    public async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function,
                    "post",
                    Route = "extension-data")]
        HttpRequest request)
    {
        logger.Hello(nameof(ExtensionDataFunction));
        _logExtensionDataFunctionTrigger(logger, null);

#pragma warning disable CA1031 // Do not catch general exception types
        try
        {
            if (request?.Body is null)
            {
                _logEmptyRequest(logger, null);
                logger.LogEmptyRequest();
                return CreateResultMessage(null);
            }

            using var reader = new StreamReader(request.Body);
            var requestBody = await reader.ReadToEndAsync();

            var doc = JsonDocument.Parse(requestBody);
            var root = doc.RootElement;

            Debug.WriteLine($"Json from request:\n{doc.FormatJson()}");

            var email = root.SafeGetString("email");
            var objectId = root.SafeGetString("objectId");
            var redirectUri = root.SafeGetString("redirect_uri");

#pragma warning disable CA1848 // Use the LoggerMessage delegates
            //TODO: Replace logging with methods generated by LoggerMessage
            logger.LogInformation("Found email {Email}", email);
            logger.LogInformation("Found objectId {ObjectId}", objectId);
            logger.LogInformation("Found redirect_uri {RedirectUri}", redirectUri);

            logger.LogInformation("Processing request for email: {Email}", email);
#pragma warning restore CA1848 // Use the LoggerMessage delegates

            var items = GetExtensionDataItems(email);
            var data = string.Join(",", items);

            return CreateResultMessage(data);
        }
        catch (Exception ex)
        {
            _logFunctionFailedError(logger, ex.Message, ex);
            return new StatusCodeResult(StatusCodes.Status500InternalServerError);
        }
#pragma warning restore CA1031 // Do not catch general exception types
    }

    private static OkObjectResult CreateResultMessage(string? data)
    {
        return new OkObjectResult(new
        {
            version = "1.0.0",
            action = "Continue",
            extension_Data = data ?? string.Empty
        });
    }

    private static List<string> GetExtensionDataItems(string email)
    {
        return ["012345", "067890", "999999"];
    }
}